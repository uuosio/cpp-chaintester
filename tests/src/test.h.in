#include <stdint.h>
#include <catch2/catch_test_macros.hpp>
#include "chaintester.h"
#include "utils.h"

using namespace std;

#define APP_PATH "@CMAKE_CURRENT_BINARY_DIR@"

#define TEST_API_SO "@CMAKE_BINARY_DIR@/tests/test-contracts/test_api/native/libtest_api_native@CMAKE_SHARED_LIBRARY_SUFFIX@"
#define HELLO_SO "@CMAKE_BINARY_DIR@/tests/test-contracts/hello/native/libhello_native@CMAKE_SHARED_LIBRARY_SUFFIX@"

#define TEST_API_WASM "@CMAKE_BINARY_DIR@/tests/test-contracts/test_api/testapi.wasm"
#define TEST_API_ABI "@CMAKE_BINARY_DIR@/tests/test-contracts/test_api/testapi.abi"


#define HELLO_WASM "@CMAKE_BINARY_DIR@/tests/test-contracts/hello/hello/hello.wasm"
#define HELLO_ABI "@CMAKE_BINARY_DIR@/tests/test-contracts/hello/hello/hello.abi"


#define TEST_API_DB_WASM "@CMAKE_SOURCE_DIR@/tests/test-contracts/test_api_db/test_api_db.wasm"
#define TEST_API_DB_ABI "@CMAKE_SOURCE_DIR@/tests/test-contracts/test_api_db/test_api_db.abi"

#define TEST_MULTI_INDEX_EXAMPLE_WASM "@CMAKE_BINARY_DIR@/tests/test-contracts/multi_index_example/multi_index_example/multi_index_example.wasm"
#define TEST_MULTI_INDEX_EXAMPLE_ABI "@CMAKE_BINARY_DIR@/tests/test-contracts/multi_index_example/multi_index_example/multi_index_example.abi"

#ifdef __cplusplus
    extern "C" void test_api_native_apply( uint64_t receiver, uint64_t code, uint64_t action );
    extern "C" void hello_native_apply( uint64_t receiver, uint64_t code, uint64_t action );
#endif


extern "C" size_t n2s(uint64_t n, char *cstr, size_t length);

static constexpr unsigned int DJBH(const char* cp)
{
  unsigned int hash = 5381;
  while (*cp)
      hash = 33 * hash ^ (unsigned char) *cp++;
  return hash;
}

static constexpr unsigned long long WASM_TEST_ACTION(const char* cls, const char* method)
{
  return static_cast<unsigned long long>(DJBH(cls)) << 32 | static_cast<unsigned long long>(DJBH(method));
}

static uint64_t TEST_METHOD(const char* CLASS, const char *METHOD) {
  return ( (uint64_t(DJBH(CLASS))<<32) | uint32_t(DJBH(METHOD)) );
}

static std::shared_ptr<JsonObject> CallFunction(ChainTester& tester, const string& account, uint64_t action, const vector<char>& data, const string& required_exception_type="", const string& exception_message="") {
    auto permissions = R""""(
    {
        "testapi": "active"
    }
    )"""";
    
    try {
        auto ret = tester.push_action(account, n2s(action), hex_str((uint8_t*)data.data(), data.size()), permissions);
        REQUIRE(!ret->HasMember("except"));
        return ret;
    } catch(chain_exception& ex) {
        auto& o = ex.value();
        REQUIRE(o.HasMember("except"));
        auto& except = o["except"];
        // WARN(JsonToString(except));
        REQUIRE(except["name"].GetString() == required_exception_type);
        if ("wasm_execution_error" == required_exception_type) {
            auto s =  except["stack"][0]["format"].GetString();
            REQUIRE(s == exception_message);
        } else if ("eosio_assert_message_exception" == required_exception_type) {
            auto s =  except["stack"][0]["data"]["s"].GetString();
            REQUIRE(string(s).find(exception_message) != std::string::npos);
        }
        return std::make_shared<JsonObject>(o.to_string());
    }
}

#define CALL_TEST_FUNCTION(_TESTER, CLS, MTH, DATA) CallFunction(_TESTER, "testapi", TEST_METHOD(CLS, MTH), DATA)
#define CALL_TEST_FUNCTION_AND_CHECK_EXCEPTION(_TESTER, CLS, MTH, DATA, EXCEPT_TYPE, EXCEPT_MSG) CallFunction(_TESTER, "testapi", TEST_METHOD(CLS, MTH), DATA, EXCEPT_TYPE, EXCEPT_MSG)
#define CALL_TEST_FUNCTION_CHECK_ASSERT_EXCEPTION(_TESTER, CLS, MTH, DATA, EXCEPT_MSG) CallFunction(_TESTER, "testapi", TEST_METHOD(CLS, MTH), DATA, "eosio_assert_message_exception", EXCEPT_MSG)

string I64Str(int64_t i);
string U64Str(uint64_t i);
string U128Str(unsigned __int128 n);
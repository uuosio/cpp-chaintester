// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "IPCChainTester.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace  ::chaintester;

class IPCChainTesterHandler : virtual public IPCChainTesterIf {
 public:
  IPCChainTesterHandler() {
    // Your initialization goes here
  }

  void init_vm_api() {
    // Your implementation goes here
    printf("init_vm_api\n");
  }

  void init_apply_request() {
    // Your implementation goes here
    printf("init_apply_request\n");
  }

  bool set_native_contract(const int32_t id, const std::string& contract, const std::string& dylib) {
    // Your implementation goes here
    printf("set_native_contract\n");
  }

  void enable_debugging(const bool enable) {
    // Your implementation goes here
    printf("enable_debugging\n");
  }

  void enable_debug_contract(const int32_t id, const std::string& contract, const bool enable) {
    // Your implementation goes here
    printf("enable_debug_contract\n");
  }

  bool is_debug_contract_enabled(const int32_t id, const std::string& contract) {
    // Your implementation goes here
    printf("is_debug_contract_enabled\n");
  }

  void pack_abi(std::string& _return, const std::string& abi) {
    // Your implementation goes here
    printf("pack_abi\n");
  }

  void pack_action_args(std::string& _return, const int32_t id, const std::string& contract, const std::string& action, const std::string& action_args) {
    // Your implementation goes here
    printf("pack_action_args\n");
  }

  void unpack_action_args(std::string& _return, const int32_t id, const std::string& contract, const std::string& action, const std::string& raw_args) {
    // Your implementation goes here
    printf("unpack_action_args\n");
  }

  int32_t new_chain(const bool initialize) {
    // Your implementation goes here
    printf("new_chain\n");
  }

  int32_t free_chain(const int32_t id) {
    // Your implementation goes here
    printf("free_chain\n");
  }

  void get_info(std::string& _return, const int32_t id) {
    // Your implementation goes here
    printf("get_info\n");
  }

  void create_key(std::string& _return, const std::string& key_type) {
    // Your implementation goes here
    printf("create_key\n");
  }

  void get_account(std::string& _return, const int32_t id, const std::string& account) {
    // Your implementation goes here
    printf("get_account\n");
  }

  void create_account(std::string& _return, const int32_t id, const std::string& creator, const std::string& account, const std::string& owner_key, const std::string& active_key, const int64_t ram_bytes, const int64_t stake_net, const int64_t stake_cpu) {
    // Your implementation goes here
    printf("create_account\n");
  }

  bool import_key(const int32_t id, const std::string& pub_key, const std::string& priv_key) {
    // Your implementation goes here
    printf("import_key\n");
  }

  void get_required_keys(std::string& _return, const int32_t id, const std::string& transaction, const std::vector<std::string> & available_keys) {
    // Your implementation goes here
    printf("get_required_keys\n");
  }

  void produce_block(const int32_t id, const int64_t next_block_skip_seconds) {
    // Your implementation goes here
    printf("produce_block\n");
  }

  void push_action(std::string& _return, const int32_t id, const std::string& account, const std::string& action, const ActionArguments& arguments, const std::string& permissions) {
    // Your implementation goes here
    printf("push_action\n");
  }

  void push_actions(std::string& _return, const int32_t id, const std::vector<Action> & actions) {
    // Your implementation goes here
    printf("push_actions\n");
  }

  void deploy_contract(std::string& _return, const int32_t id, const std::string& account, const std::string& wasm, const std::string& abi) {
    // Your implementation goes here
    printf("deploy_contract\n");
  }

  void get_table_rows(std::string& _return, const int32_t id, const bool json, const std::string& code, const std::string& scope, const std::string& table, const std::string& lower_bound, const std::string& upper_bound, const int64_t limit, const std::string& key_type, const std::string& index_position, const bool reverse, const bool show_payer) {
    // Your implementation goes here
    printf("get_table_rows\n");
  }

};

int main(int argc, char **argv) {
  int port = 9090;
  ::std::shared_ptr<IPCChainTesterHandler> handler(new IPCChainTesterHandler());
  ::std::shared_ptr<TProcessor> processor(new IPCChainTesterProcessor(handler));
  ::std::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  ::std::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  ::std::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}


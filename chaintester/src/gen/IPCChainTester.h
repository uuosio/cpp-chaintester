/**
 * Autogenerated by Thrift Compiler (0.15.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef IPCChainTester_H
#define IPCChainTester_H

#include <thrift/TDispatchProcessor.h>
#include <thrift/async/TConcurrentClientSyncInfo.h>
#include <memory>
#include "interfaces_types.h"

namespace chaintester {

#ifdef _MSC_VER
  #pragma warning( push )
  #pragma warning (disable : 4250 ) //inheriting methods via dominance 
#endif

class IPCChainTesterIf {
 public:
  virtual ~IPCChainTesterIf() {}
  virtual void init_vm_api() = 0;
  virtual void init_apply_request() = 0;
  virtual bool set_native_contract(const std::string& contract, const std::string& dylib) = 0;
  virtual void enable_debug_contract(const int32_t id, const std::string& contract, const bool enable) = 0;
  virtual bool is_debug_contract_enabled(const int32_t id, const std::string& contract) = 0;
  virtual void pack_abi(std::string& _return, const std::string& abi) = 0;
  virtual void pack_action_args(std::string& _return, const int32_t id, const std::string& contract, const std::string& action, const std::string& action_args) = 0;
  virtual void unpack_action_args(std::string& _return, const int32_t id, const std::string& contract, const std::string& action, const std::string& raw_args) = 0;
  virtual int32_t new_chain(const bool initialize) = 0;
  virtual int32_t free_chain(const int32_t id) = 0;
  virtual void get_info(std::string& _return, const int32_t id) = 0;
  virtual void create_key(std::string& _return, const std::string& key_type) = 0;
  virtual void get_account(std::string& _return, const int32_t id, const std::string& account) = 0;
  virtual void create_account(std::string& _return, const int32_t id, const std::string& creator, const std::string& account, const std::string& owner_key, const std::string& active_key, const int64_t ram_bytes, const int64_t stake_net, const int64_t stake_cpu) = 0;
  virtual bool import_key(const int32_t id, const std::string& pub_key, const std::string& priv_key) = 0;
  virtual void get_required_keys(std::string& _return, const int32_t id, const std::string& transaction, const std::vector<std::string> & available_keys) = 0;
  virtual void produce_block(const int32_t id, const int64_t next_block_skip_seconds) = 0;
  virtual void push_action(std::string& _return, const int32_t id, const std::string& account, const std::string& action, const ActionArguments& arguments, const std::string& permissions) = 0;
  virtual void push_actions(std::string& _return, const int32_t id, const std::vector<Action> & actions) = 0;
  virtual void deploy_contract(std::string& _return, const int32_t id, const std::string& account, const std::string& wasm, const std::string& abi) = 0;
  virtual void get_table_rows(std::string& _return, const int32_t id, const bool json, const std::string& code, const std::string& scope, const std::string& table, const std::string& lower_bound, const std::string& upper_bound, const int64_t limit, const std::string& key_type, const std::string& index_position, const bool reverse, const bool show_payer) = 0;
};

class IPCChainTesterIfFactory {
 public:
  typedef IPCChainTesterIf Handler;

  virtual ~IPCChainTesterIfFactory() {}

  virtual IPCChainTesterIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(IPCChainTesterIf* /* handler */) = 0;
  };

class IPCChainTesterIfSingletonFactory : virtual public IPCChainTesterIfFactory {
 public:
  IPCChainTesterIfSingletonFactory(const ::std::shared_ptr<IPCChainTesterIf>& iface) : iface_(iface) {}
  virtual ~IPCChainTesterIfSingletonFactory() {}

  virtual IPCChainTesterIf* getHandler(const ::apache::thrift::TConnectionInfo&) override {
    return iface_.get();
  }
  virtual void releaseHandler(IPCChainTesterIf* /* handler */) override {}

 protected:
  ::std::shared_ptr<IPCChainTesterIf> iface_;
};

class IPCChainTesterNull : virtual public IPCChainTesterIf {
 public:
  virtual ~IPCChainTesterNull() {}
  void init_vm_api() override {
    return;
  }
  void init_apply_request() override {
    return;
  }
  bool set_native_contract(const std::string& /* contract */, const std::string& /* dylib */) override {
    bool _return = false;
    return _return;
  }
  void enable_debug_contract(const int32_t /* id */, const std::string& /* contract */, const bool /* enable */) override {
    return;
  }
  bool is_debug_contract_enabled(const int32_t /* id */, const std::string& /* contract */) override {
    bool _return = false;
    return _return;
  }
  void pack_abi(std::string& /* _return */, const std::string& /* abi */) override {
    return;
  }
  void pack_action_args(std::string& /* _return */, const int32_t /* id */, const std::string& /* contract */, const std::string& /* action */, const std::string& /* action_args */) override {
    return;
  }
  void unpack_action_args(std::string& /* _return */, const int32_t /* id */, const std::string& /* contract */, const std::string& /* action */, const std::string& /* raw_args */) override {
    return;
  }
  int32_t new_chain(const bool /* initialize */) override {
    int32_t _return = 0;
    return _return;
  }
  int32_t free_chain(const int32_t /* id */) override {
    int32_t _return = 0;
    return _return;
  }
  void get_info(std::string& /* _return */, const int32_t /* id */) override {
    return;
  }
  void create_key(std::string& /* _return */, const std::string& /* key_type */) override {
    return;
  }
  void get_account(std::string& /* _return */, const int32_t /* id */, const std::string& /* account */) override {
    return;
  }
  void create_account(std::string& /* _return */, const int32_t /* id */, const std::string& /* creator */, const std::string& /* account */, const std::string& /* owner_key */, const std::string& /* active_key */, const int64_t /* ram_bytes */, const int64_t /* stake_net */, const int64_t /* stake_cpu */) override {
    return;
  }
  bool import_key(const int32_t /* id */, const std::string& /* pub_key */, const std::string& /* priv_key */) override {
    bool _return = false;
    return _return;
  }
  void get_required_keys(std::string& /* _return */, const int32_t /* id */, const std::string& /* transaction */, const std::vector<std::string> & /* available_keys */) override {
    return;
  }
  void produce_block(const int32_t /* id */, const int64_t /* next_block_skip_seconds */) override {
    return;
  }
  void push_action(std::string& /* _return */, const int32_t /* id */, const std::string& /* account */, const std::string& /* action */, const ActionArguments& /* arguments */, const std::string& /* permissions */) override {
    return;
  }
  void push_actions(std::string& /* _return */, const int32_t /* id */, const std::vector<Action> & /* actions */) override {
    return;
  }
  void deploy_contract(std::string& /* _return */, const int32_t /* id */, const std::string& /* account */, const std::string& /* wasm */, const std::string& /* abi */) override {
    return;
  }
  void get_table_rows(std::string& /* _return */, const int32_t /* id */, const bool /* json */, const std::string& /* code */, const std::string& /* scope */, const std::string& /* table */, const std::string& /* lower_bound */, const std::string& /* upper_bound */, const int64_t /* limit */, const std::string& /* key_type */, const std::string& /* index_position */, const bool /* reverse */, const bool /* show_payer */) override {
    return;
  }
};


class IPCChainTester_init_vm_api_args {
 public:

  IPCChainTester_init_vm_api_args(const IPCChainTester_init_vm_api_args&) noexcept;
  IPCChainTester_init_vm_api_args& operator=(const IPCChainTester_init_vm_api_args&) noexcept;
  IPCChainTester_init_vm_api_args() noexcept {
  }

  virtual ~IPCChainTester_init_vm_api_args() noexcept;

  bool operator == (const IPCChainTester_init_vm_api_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const IPCChainTester_init_vm_api_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_init_vm_api_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class IPCChainTester_init_vm_api_pargs {
 public:


  virtual ~IPCChainTester_init_vm_api_pargs() noexcept;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class IPCChainTester_init_apply_request_args {
 public:

  IPCChainTester_init_apply_request_args(const IPCChainTester_init_apply_request_args&) noexcept;
  IPCChainTester_init_apply_request_args& operator=(const IPCChainTester_init_apply_request_args&) noexcept;
  IPCChainTester_init_apply_request_args() noexcept {
  }

  virtual ~IPCChainTester_init_apply_request_args() noexcept;

  bool operator == (const IPCChainTester_init_apply_request_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const IPCChainTester_init_apply_request_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_init_apply_request_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class IPCChainTester_init_apply_request_pargs {
 public:


  virtual ~IPCChainTester_init_apply_request_pargs() noexcept;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _IPCChainTester_set_native_contract_args__isset {
  _IPCChainTester_set_native_contract_args__isset() : contract(false), dylib(false) {}
  bool contract :1;
  bool dylib :1;
} _IPCChainTester_set_native_contract_args__isset;

class IPCChainTester_set_native_contract_args {
 public:

  IPCChainTester_set_native_contract_args(const IPCChainTester_set_native_contract_args&);
  IPCChainTester_set_native_contract_args& operator=(const IPCChainTester_set_native_contract_args&);
  IPCChainTester_set_native_contract_args() noexcept
                                          : contract(),
                                            dylib() {
  }

  virtual ~IPCChainTester_set_native_contract_args() noexcept;
  std::string contract;
  std::string dylib;

  _IPCChainTester_set_native_contract_args__isset __isset;

  void __set_contract(const std::string& val);

  void __set_dylib(const std::string& val);

  bool operator == (const IPCChainTester_set_native_contract_args & rhs) const
  {
    if (!(contract == rhs.contract))
      return false;
    if (!(dylib == rhs.dylib))
      return false;
    return true;
  }
  bool operator != (const IPCChainTester_set_native_contract_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_set_native_contract_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class IPCChainTester_set_native_contract_pargs {
 public:


  virtual ~IPCChainTester_set_native_contract_pargs() noexcept;
  const std::string* contract;
  const std::string* dylib;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _IPCChainTester_set_native_contract_result__isset {
  _IPCChainTester_set_native_contract_result__isset() : success(false) {}
  bool success :1;
} _IPCChainTester_set_native_contract_result__isset;

class IPCChainTester_set_native_contract_result {
 public:

  IPCChainTester_set_native_contract_result(const IPCChainTester_set_native_contract_result&) noexcept;
  IPCChainTester_set_native_contract_result& operator=(const IPCChainTester_set_native_contract_result&) noexcept;
  IPCChainTester_set_native_contract_result() noexcept
                                            : success(0) {
  }

  virtual ~IPCChainTester_set_native_contract_result() noexcept;
  bool success;

  _IPCChainTester_set_native_contract_result__isset __isset;

  void __set_success(const bool val);

  bool operator == (const IPCChainTester_set_native_contract_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const IPCChainTester_set_native_contract_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_set_native_contract_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _IPCChainTester_set_native_contract_presult__isset {
  _IPCChainTester_set_native_contract_presult__isset() : success(false) {}
  bool success :1;
} _IPCChainTester_set_native_contract_presult__isset;

class IPCChainTester_set_native_contract_presult {
 public:


  virtual ~IPCChainTester_set_native_contract_presult() noexcept;
  bool* success;

  _IPCChainTester_set_native_contract_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _IPCChainTester_enable_debug_contract_args__isset {
  _IPCChainTester_enable_debug_contract_args__isset() : id(false), contract(false), enable(false) {}
  bool id :1;
  bool contract :1;
  bool enable :1;
} _IPCChainTester_enable_debug_contract_args__isset;

class IPCChainTester_enable_debug_contract_args {
 public:

  IPCChainTester_enable_debug_contract_args(const IPCChainTester_enable_debug_contract_args&);
  IPCChainTester_enable_debug_contract_args& operator=(const IPCChainTester_enable_debug_contract_args&);
  IPCChainTester_enable_debug_contract_args() noexcept
                                            : id(0),
                                              contract(),
                                              enable(0) {
  }

  virtual ~IPCChainTester_enable_debug_contract_args() noexcept;
  int32_t id;
  std::string contract;
  bool enable;

  _IPCChainTester_enable_debug_contract_args__isset __isset;

  void __set_id(const int32_t val);

  void __set_contract(const std::string& val);

  void __set_enable(const bool val);

  bool operator == (const IPCChainTester_enable_debug_contract_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(contract == rhs.contract))
      return false;
    if (!(enable == rhs.enable))
      return false;
    return true;
  }
  bool operator != (const IPCChainTester_enable_debug_contract_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_enable_debug_contract_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class IPCChainTester_enable_debug_contract_pargs {
 public:


  virtual ~IPCChainTester_enable_debug_contract_pargs() noexcept;
  const int32_t* id;
  const std::string* contract;
  const bool* enable;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class IPCChainTester_enable_debug_contract_result {
 public:

  IPCChainTester_enable_debug_contract_result(const IPCChainTester_enable_debug_contract_result&) noexcept;
  IPCChainTester_enable_debug_contract_result& operator=(const IPCChainTester_enable_debug_contract_result&) noexcept;
  IPCChainTester_enable_debug_contract_result() noexcept {
  }

  virtual ~IPCChainTester_enable_debug_contract_result() noexcept;

  bool operator == (const IPCChainTester_enable_debug_contract_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const IPCChainTester_enable_debug_contract_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_enable_debug_contract_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class IPCChainTester_enable_debug_contract_presult {
 public:


  virtual ~IPCChainTester_enable_debug_contract_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _IPCChainTester_is_debug_contract_enabled_args__isset {
  _IPCChainTester_is_debug_contract_enabled_args__isset() : id(false), contract(false) {}
  bool id :1;
  bool contract :1;
} _IPCChainTester_is_debug_contract_enabled_args__isset;

class IPCChainTester_is_debug_contract_enabled_args {
 public:

  IPCChainTester_is_debug_contract_enabled_args(const IPCChainTester_is_debug_contract_enabled_args&);
  IPCChainTester_is_debug_contract_enabled_args& operator=(const IPCChainTester_is_debug_contract_enabled_args&);
  IPCChainTester_is_debug_contract_enabled_args() noexcept
                                                : id(0),
                                                  contract() {
  }

  virtual ~IPCChainTester_is_debug_contract_enabled_args() noexcept;
  int32_t id;
  std::string contract;

  _IPCChainTester_is_debug_contract_enabled_args__isset __isset;

  void __set_id(const int32_t val);

  void __set_contract(const std::string& val);

  bool operator == (const IPCChainTester_is_debug_contract_enabled_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(contract == rhs.contract))
      return false;
    return true;
  }
  bool operator != (const IPCChainTester_is_debug_contract_enabled_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_is_debug_contract_enabled_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class IPCChainTester_is_debug_contract_enabled_pargs {
 public:


  virtual ~IPCChainTester_is_debug_contract_enabled_pargs() noexcept;
  const int32_t* id;
  const std::string* contract;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _IPCChainTester_is_debug_contract_enabled_result__isset {
  _IPCChainTester_is_debug_contract_enabled_result__isset() : success(false) {}
  bool success :1;
} _IPCChainTester_is_debug_contract_enabled_result__isset;

class IPCChainTester_is_debug_contract_enabled_result {
 public:

  IPCChainTester_is_debug_contract_enabled_result(const IPCChainTester_is_debug_contract_enabled_result&) noexcept;
  IPCChainTester_is_debug_contract_enabled_result& operator=(const IPCChainTester_is_debug_contract_enabled_result&) noexcept;
  IPCChainTester_is_debug_contract_enabled_result() noexcept
                                                  : success(0) {
  }

  virtual ~IPCChainTester_is_debug_contract_enabled_result() noexcept;
  bool success;

  _IPCChainTester_is_debug_contract_enabled_result__isset __isset;

  void __set_success(const bool val);

  bool operator == (const IPCChainTester_is_debug_contract_enabled_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const IPCChainTester_is_debug_contract_enabled_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_is_debug_contract_enabled_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _IPCChainTester_is_debug_contract_enabled_presult__isset {
  _IPCChainTester_is_debug_contract_enabled_presult__isset() : success(false) {}
  bool success :1;
} _IPCChainTester_is_debug_contract_enabled_presult__isset;

class IPCChainTester_is_debug_contract_enabled_presult {
 public:


  virtual ~IPCChainTester_is_debug_contract_enabled_presult() noexcept;
  bool* success;

  _IPCChainTester_is_debug_contract_enabled_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _IPCChainTester_pack_abi_args__isset {
  _IPCChainTester_pack_abi_args__isset() : abi(false) {}
  bool abi :1;
} _IPCChainTester_pack_abi_args__isset;

class IPCChainTester_pack_abi_args {
 public:

  IPCChainTester_pack_abi_args(const IPCChainTester_pack_abi_args&);
  IPCChainTester_pack_abi_args& operator=(const IPCChainTester_pack_abi_args&);
  IPCChainTester_pack_abi_args() noexcept
                               : abi() {
  }

  virtual ~IPCChainTester_pack_abi_args() noexcept;
  std::string abi;

  _IPCChainTester_pack_abi_args__isset __isset;

  void __set_abi(const std::string& val);

  bool operator == (const IPCChainTester_pack_abi_args & rhs) const
  {
    if (!(abi == rhs.abi))
      return false;
    return true;
  }
  bool operator != (const IPCChainTester_pack_abi_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_pack_abi_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class IPCChainTester_pack_abi_pargs {
 public:


  virtual ~IPCChainTester_pack_abi_pargs() noexcept;
  const std::string* abi;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _IPCChainTester_pack_abi_result__isset {
  _IPCChainTester_pack_abi_result__isset() : success(false) {}
  bool success :1;
} _IPCChainTester_pack_abi_result__isset;

class IPCChainTester_pack_abi_result {
 public:

  IPCChainTester_pack_abi_result(const IPCChainTester_pack_abi_result&);
  IPCChainTester_pack_abi_result& operator=(const IPCChainTester_pack_abi_result&);
  IPCChainTester_pack_abi_result() noexcept
                                 : success() {
  }

  virtual ~IPCChainTester_pack_abi_result() noexcept;
  std::string success;

  _IPCChainTester_pack_abi_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const IPCChainTester_pack_abi_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const IPCChainTester_pack_abi_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_pack_abi_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _IPCChainTester_pack_abi_presult__isset {
  _IPCChainTester_pack_abi_presult__isset() : success(false) {}
  bool success :1;
} _IPCChainTester_pack_abi_presult__isset;

class IPCChainTester_pack_abi_presult {
 public:


  virtual ~IPCChainTester_pack_abi_presult() noexcept;
  std::string* success;

  _IPCChainTester_pack_abi_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _IPCChainTester_pack_action_args_args__isset {
  _IPCChainTester_pack_action_args_args__isset() : id(false), contract(false), action(false), action_args(false) {}
  bool id :1;
  bool contract :1;
  bool action :1;
  bool action_args :1;
} _IPCChainTester_pack_action_args_args__isset;

class IPCChainTester_pack_action_args_args {
 public:

  IPCChainTester_pack_action_args_args(const IPCChainTester_pack_action_args_args&);
  IPCChainTester_pack_action_args_args& operator=(const IPCChainTester_pack_action_args_args&);
  IPCChainTester_pack_action_args_args() noexcept
                                       : id(0),
                                         contract(),
                                         action(),
                                         action_args() {
  }

  virtual ~IPCChainTester_pack_action_args_args() noexcept;
  int32_t id;
  std::string contract;
  std::string action;
  std::string action_args;

  _IPCChainTester_pack_action_args_args__isset __isset;

  void __set_id(const int32_t val);

  void __set_contract(const std::string& val);

  void __set_action(const std::string& val);

  void __set_action_args(const std::string& val);

  bool operator == (const IPCChainTester_pack_action_args_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(contract == rhs.contract))
      return false;
    if (!(action == rhs.action))
      return false;
    if (!(action_args == rhs.action_args))
      return false;
    return true;
  }
  bool operator != (const IPCChainTester_pack_action_args_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_pack_action_args_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class IPCChainTester_pack_action_args_pargs {
 public:


  virtual ~IPCChainTester_pack_action_args_pargs() noexcept;
  const int32_t* id;
  const std::string* contract;
  const std::string* action;
  const std::string* action_args;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _IPCChainTester_pack_action_args_result__isset {
  _IPCChainTester_pack_action_args_result__isset() : success(false) {}
  bool success :1;
} _IPCChainTester_pack_action_args_result__isset;

class IPCChainTester_pack_action_args_result {
 public:

  IPCChainTester_pack_action_args_result(const IPCChainTester_pack_action_args_result&);
  IPCChainTester_pack_action_args_result& operator=(const IPCChainTester_pack_action_args_result&);
  IPCChainTester_pack_action_args_result() noexcept
                                         : success() {
  }

  virtual ~IPCChainTester_pack_action_args_result() noexcept;
  std::string success;

  _IPCChainTester_pack_action_args_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const IPCChainTester_pack_action_args_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const IPCChainTester_pack_action_args_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_pack_action_args_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _IPCChainTester_pack_action_args_presult__isset {
  _IPCChainTester_pack_action_args_presult__isset() : success(false) {}
  bool success :1;
} _IPCChainTester_pack_action_args_presult__isset;

class IPCChainTester_pack_action_args_presult {
 public:


  virtual ~IPCChainTester_pack_action_args_presult() noexcept;
  std::string* success;

  _IPCChainTester_pack_action_args_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _IPCChainTester_unpack_action_args_args__isset {
  _IPCChainTester_unpack_action_args_args__isset() : id(false), contract(false), action(false), raw_args(false) {}
  bool id :1;
  bool contract :1;
  bool action :1;
  bool raw_args :1;
} _IPCChainTester_unpack_action_args_args__isset;

class IPCChainTester_unpack_action_args_args {
 public:

  IPCChainTester_unpack_action_args_args(const IPCChainTester_unpack_action_args_args&);
  IPCChainTester_unpack_action_args_args& operator=(const IPCChainTester_unpack_action_args_args&);
  IPCChainTester_unpack_action_args_args() noexcept
                                         : id(0),
                                           contract(),
                                           action(),
                                           raw_args() {
  }

  virtual ~IPCChainTester_unpack_action_args_args() noexcept;
  int32_t id;
  std::string contract;
  std::string action;
  std::string raw_args;

  _IPCChainTester_unpack_action_args_args__isset __isset;

  void __set_id(const int32_t val);

  void __set_contract(const std::string& val);

  void __set_action(const std::string& val);

  void __set_raw_args(const std::string& val);

  bool operator == (const IPCChainTester_unpack_action_args_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(contract == rhs.contract))
      return false;
    if (!(action == rhs.action))
      return false;
    if (!(raw_args == rhs.raw_args))
      return false;
    return true;
  }
  bool operator != (const IPCChainTester_unpack_action_args_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_unpack_action_args_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class IPCChainTester_unpack_action_args_pargs {
 public:


  virtual ~IPCChainTester_unpack_action_args_pargs() noexcept;
  const int32_t* id;
  const std::string* contract;
  const std::string* action;
  const std::string* raw_args;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _IPCChainTester_unpack_action_args_result__isset {
  _IPCChainTester_unpack_action_args_result__isset() : success(false) {}
  bool success :1;
} _IPCChainTester_unpack_action_args_result__isset;

class IPCChainTester_unpack_action_args_result {
 public:

  IPCChainTester_unpack_action_args_result(const IPCChainTester_unpack_action_args_result&);
  IPCChainTester_unpack_action_args_result& operator=(const IPCChainTester_unpack_action_args_result&);
  IPCChainTester_unpack_action_args_result() noexcept
                                           : success() {
  }

  virtual ~IPCChainTester_unpack_action_args_result() noexcept;
  std::string success;

  _IPCChainTester_unpack_action_args_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const IPCChainTester_unpack_action_args_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const IPCChainTester_unpack_action_args_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_unpack_action_args_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _IPCChainTester_unpack_action_args_presult__isset {
  _IPCChainTester_unpack_action_args_presult__isset() : success(false) {}
  bool success :1;
} _IPCChainTester_unpack_action_args_presult__isset;

class IPCChainTester_unpack_action_args_presult {
 public:


  virtual ~IPCChainTester_unpack_action_args_presult() noexcept;
  std::string* success;

  _IPCChainTester_unpack_action_args_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _IPCChainTester_new_chain_args__isset {
  _IPCChainTester_new_chain_args__isset() : initialize(false) {}
  bool initialize :1;
} _IPCChainTester_new_chain_args__isset;

class IPCChainTester_new_chain_args {
 public:

  IPCChainTester_new_chain_args(const IPCChainTester_new_chain_args&) noexcept;
  IPCChainTester_new_chain_args& operator=(const IPCChainTester_new_chain_args&) noexcept;
  IPCChainTester_new_chain_args() noexcept
                                : initialize(0) {
  }

  virtual ~IPCChainTester_new_chain_args() noexcept;
  bool initialize;

  _IPCChainTester_new_chain_args__isset __isset;

  void __set_initialize(const bool val);

  bool operator == (const IPCChainTester_new_chain_args & rhs) const
  {
    if (!(initialize == rhs.initialize))
      return false;
    return true;
  }
  bool operator != (const IPCChainTester_new_chain_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_new_chain_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class IPCChainTester_new_chain_pargs {
 public:


  virtual ~IPCChainTester_new_chain_pargs() noexcept;
  const bool* initialize;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _IPCChainTester_new_chain_result__isset {
  _IPCChainTester_new_chain_result__isset() : success(false) {}
  bool success :1;
} _IPCChainTester_new_chain_result__isset;

class IPCChainTester_new_chain_result {
 public:

  IPCChainTester_new_chain_result(const IPCChainTester_new_chain_result&) noexcept;
  IPCChainTester_new_chain_result& operator=(const IPCChainTester_new_chain_result&) noexcept;
  IPCChainTester_new_chain_result() noexcept
                                  : success(0) {
  }

  virtual ~IPCChainTester_new_chain_result() noexcept;
  int32_t success;

  _IPCChainTester_new_chain_result__isset __isset;

  void __set_success(const int32_t val);

  bool operator == (const IPCChainTester_new_chain_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const IPCChainTester_new_chain_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_new_chain_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _IPCChainTester_new_chain_presult__isset {
  _IPCChainTester_new_chain_presult__isset() : success(false) {}
  bool success :1;
} _IPCChainTester_new_chain_presult__isset;

class IPCChainTester_new_chain_presult {
 public:


  virtual ~IPCChainTester_new_chain_presult() noexcept;
  int32_t* success;

  _IPCChainTester_new_chain_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _IPCChainTester_free_chain_args__isset {
  _IPCChainTester_free_chain_args__isset() : id(false) {}
  bool id :1;
} _IPCChainTester_free_chain_args__isset;

class IPCChainTester_free_chain_args {
 public:

  IPCChainTester_free_chain_args(const IPCChainTester_free_chain_args&) noexcept;
  IPCChainTester_free_chain_args& operator=(const IPCChainTester_free_chain_args&) noexcept;
  IPCChainTester_free_chain_args() noexcept
                                 : id(0) {
  }

  virtual ~IPCChainTester_free_chain_args() noexcept;
  int32_t id;

  _IPCChainTester_free_chain_args__isset __isset;

  void __set_id(const int32_t val);

  bool operator == (const IPCChainTester_free_chain_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const IPCChainTester_free_chain_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_free_chain_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class IPCChainTester_free_chain_pargs {
 public:


  virtual ~IPCChainTester_free_chain_pargs() noexcept;
  const int32_t* id;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _IPCChainTester_free_chain_result__isset {
  _IPCChainTester_free_chain_result__isset() : success(false) {}
  bool success :1;
} _IPCChainTester_free_chain_result__isset;

class IPCChainTester_free_chain_result {
 public:

  IPCChainTester_free_chain_result(const IPCChainTester_free_chain_result&) noexcept;
  IPCChainTester_free_chain_result& operator=(const IPCChainTester_free_chain_result&) noexcept;
  IPCChainTester_free_chain_result() noexcept
                                   : success(0) {
  }

  virtual ~IPCChainTester_free_chain_result() noexcept;
  int32_t success;

  _IPCChainTester_free_chain_result__isset __isset;

  void __set_success(const int32_t val);

  bool operator == (const IPCChainTester_free_chain_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const IPCChainTester_free_chain_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_free_chain_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _IPCChainTester_free_chain_presult__isset {
  _IPCChainTester_free_chain_presult__isset() : success(false) {}
  bool success :1;
} _IPCChainTester_free_chain_presult__isset;

class IPCChainTester_free_chain_presult {
 public:


  virtual ~IPCChainTester_free_chain_presult() noexcept;
  int32_t* success;

  _IPCChainTester_free_chain_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _IPCChainTester_get_info_args__isset {
  _IPCChainTester_get_info_args__isset() : id(false) {}
  bool id :1;
} _IPCChainTester_get_info_args__isset;

class IPCChainTester_get_info_args {
 public:

  IPCChainTester_get_info_args(const IPCChainTester_get_info_args&) noexcept;
  IPCChainTester_get_info_args& operator=(const IPCChainTester_get_info_args&) noexcept;
  IPCChainTester_get_info_args() noexcept
                               : id(0) {
  }

  virtual ~IPCChainTester_get_info_args() noexcept;
  int32_t id;

  _IPCChainTester_get_info_args__isset __isset;

  void __set_id(const int32_t val);

  bool operator == (const IPCChainTester_get_info_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const IPCChainTester_get_info_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_get_info_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class IPCChainTester_get_info_pargs {
 public:


  virtual ~IPCChainTester_get_info_pargs() noexcept;
  const int32_t* id;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _IPCChainTester_get_info_result__isset {
  _IPCChainTester_get_info_result__isset() : success(false) {}
  bool success :1;
} _IPCChainTester_get_info_result__isset;

class IPCChainTester_get_info_result {
 public:

  IPCChainTester_get_info_result(const IPCChainTester_get_info_result&);
  IPCChainTester_get_info_result& operator=(const IPCChainTester_get_info_result&);
  IPCChainTester_get_info_result() noexcept
                                 : success() {
  }

  virtual ~IPCChainTester_get_info_result() noexcept;
  std::string success;

  _IPCChainTester_get_info_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const IPCChainTester_get_info_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const IPCChainTester_get_info_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_get_info_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _IPCChainTester_get_info_presult__isset {
  _IPCChainTester_get_info_presult__isset() : success(false) {}
  bool success :1;
} _IPCChainTester_get_info_presult__isset;

class IPCChainTester_get_info_presult {
 public:


  virtual ~IPCChainTester_get_info_presult() noexcept;
  std::string* success;

  _IPCChainTester_get_info_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _IPCChainTester_create_key_args__isset {
  _IPCChainTester_create_key_args__isset() : key_type(false) {}
  bool key_type :1;
} _IPCChainTester_create_key_args__isset;

class IPCChainTester_create_key_args {
 public:

  IPCChainTester_create_key_args(const IPCChainTester_create_key_args&);
  IPCChainTester_create_key_args& operator=(const IPCChainTester_create_key_args&);
  IPCChainTester_create_key_args() noexcept
                                 : key_type() {
  }

  virtual ~IPCChainTester_create_key_args() noexcept;
  std::string key_type;

  _IPCChainTester_create_key_args__isset __isset;

  void __set_key_type(const std::string& val);

  bool operator == (const IPCChainTester_create_key_args & rhs) const
  {
    if (!(key_type == rhs.key_type))
      return false;
    return true;
  }
  bool operator != (const IPCChainTester_create_key_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_create_key_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class IPCChainTester_create_key_pargs {
 public:


  virtual ~IPCChainTester_create_key_pargs() noexcept;
  const std::string* key_type;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _IPCChainTester_create_key_result__isset {
  _IPCChainTester_create_key_result__isset() : success(false) {}
  bool success :1;
} _IPCChainTester_create_key_result__isset;

class IPCChainTester_create_key_result {
 public:

  IPCChainTester_create_key_result(const IPCChainTester_create_key_result&);
  IPCChainTester_create_key_result& operator=(const IPCChainTester_create_key_result&);
  IPCChainTester_create_key_result() noexcept
                                   : success() {
  }

  virtual ~IPCChainTester_create_key_result() noexcept;
  std::string success;

  _IPCChainTester_create_key_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const IPCChainTester_create_key_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const IPCChainTester_create_key_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_create_key_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _IPCChainTester_create_key_presult__isset {
  _IPCChainTester_create_key_presult__isset() : success(false) {}
  bool success :1;
} _IPCChainTester_create_key_presult__isset;

class IPCChainTester_create_key_presult {
 public:


  virtual ~IPCChainTester_create_key_presult() noexcept;
  std::string* success;

  _IPCChainTester_create_key_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _IPCChainTester_get_account_args__isset {
  _IPCChainTester_get_account_args__isset() : id(false), account(false) {}
  bool id :1;
  bool account :1;
} _IPCChainTester_get_account_args__isset;

class IPCChainTester_get_account_args {
 public:

  IPCChainTester_get_account_args(const IPCChainTester_get_account_args&);
  IPCChainTester_get_account_args& operator=(const IPCChainTester_get_account_args&);
  IPCChainTester_get_account_args() noexcept
                                  : id(0),
                                    account() {
  }

  virtual ~IPCChainTester_get_account_args() noexcept;
  int32_t id;
  std::string account;

  _IPCChainTester_get_account_args__isset __isset;

  void __set_id(const int32_t val);

  void __set_account(const std::string& val);

  bool operator == (const IPCChainTester_get_account_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(account == rhs.account))
      return false;
    return true;
  }
  bool operator != (const IPCChainTester_get_account_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_get_account_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class IPCChainTester_get_account_pargs {
 public:


  virtual ~IPCChainTester_get_account_pargs() noexcept;
  const int32_t* id;
  const std::string* account;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _IPCChainTester_get_account_result__isset {
  _IPCChainTester_get_account_result__isset() : success(false) {}
  bool success :1;
} _IPCChainTester_get_account_result__isset;

class IPCChainTester_get_account_result {
 public:

  IPCChainTester_get_account_result(const IPCChainTester_get_account_result&);
  IPCChainTester_get_account_result& operator=(const IPCChainTester_get_account_result&);
  IPCChainTester_get_account_result() noexcept
                                    : success() {
  }

  virtual ~IPCChainTester_get_account_result() noexcept;
  std::string success;

  _IPCChainTester_get_account_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const IPCChainTester_get_account_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const IPCChainTester_get_account_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_get_account_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _IPCChainTester_get_account_presult__isset {
  _IPCChainTester_get_account_presult__isset() : success(false) {}
  bool success :1;
} _IPCChainTester_get_account_presult__isset;

class IPCChainTester_get_account_presult {
 public:


  virtual ~IPCChainTester_get_account_presult() noexcept;
  std::string* success;

  _IPCChainTester_get_account_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _IPCChainTester_create_account_args__isset {
  _IPCChainTester_create_account_args__isset() : id(false), creator(false), account(false), owner_key(false), active_key(false), ram_bytes(false), stake_net(false), stake_cpu(false) {}
  bool id :1;
  bool creator :1;
  bool account :1;
  bool owner_key :1;
  bool active_key :1;
  bool ram_bytes :1;
  bool stake_net :1;
  bool stake_cpu :1;
} _IPCChainTester_create_account_args__isset;

class IPCChainTester_create_account_args {
 public:

  IPCChainTester_create_account_args(const IPCChainTester_create_account_args&);
  IPCChainTester_create_account_args& operator=(const IPCChainTester_create_account_args&);
  IPCChainTester_create_account_args() noexcept
                                     : id(0),
                                       creator(),
                                       account(),
                                       owner_key(),
                                       active_key(),
                                       ram_bytes(0),
                                       stake_net(0),
                                       stake_cpu(0) {
  }

  virtual ~IPCChainTester_create_account_args() noexcept;
  int32_t id;
  std::string creator;
  std::string account;
  std::string owner_key;
  std::string active_key;
  int64_t ram_bytes;
  int64_t stake_net;
  int64_t stake_cpu;

  _IPCChainTester_create_account_args__isset __isset;

  void __set_id(const int32_t val);

  void __set_creator(const std::string& val);

  void __set_account(const std::string& val);

  void __set_owner_key(const std::string& val);

  void __set_active_key(const std::string& val);

  void __set_ram_bytes(const int64_t val);

  void __set_stake_net(const int64_t val);

  void __set_stake_cpu(const int64_t val);

  bool operator == (const IPCChainTester_create_account_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(creator == rhs.creator))
      return false;
    if (!(account == rhs.account))
      return false;
    if (!(owner_key == rhs.owner_key))
      return false;
    if (!(active_key == rhs.active_key))
      return false;
    if (!(ram_bytes == rhs.ram_bytes))
      return false;
    if (!(stake_net == rhs.stake_net))
      return false;
    if (!(stake_cpu == rhs.stake_cpu))
      return false;
    return true;
  }
  bool operator != (const IPCChainTester_create_account_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_create_account_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class IPCChainTester_create_account_pargs {
 public:


  virtual ~IPCChainTester_create_account_pargs() noexcept;
  const int32_t* id;
  const std::string* creator;
  const std::string* account;
  const std::string* owner_key;
  const std::string* active_key;
  const int64_t* ram_bytes;
  const int64_t* stake_net;
  const int64_t* stake_cpu;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _IPCChainTester_create_account_result__isset {
  _IPCChainTester_create_account_result__isset() : success(false) {}
  bool success :1;
} _IPCChainTester_create_account_result__isset;

class IPCChainTester_create_account_result {
 public:

  IPCChainTester_create_account_result(const IPCChainTester_create_account_result&);
  IPCChainTester_create_account_result& operator=(const IPCChainTester_create_account_result&);
  IPCChainTester_create_account_result() noexcept
                                       : success() {
  }

  virtual ~IPCChainTester_create_account_result() noexcept;
  std::string success;

  _IPCChainTester_create_account_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const IPCChainTester_create_account_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const IPCChainTester_create_account_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_create_account_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _IPCChainTester_create_account_presult__isset {
  _IPCChainTester_create_account_presult__isset() : success(false) {}
  bool success :1;
} _IPCChainTester_create_account_presult__isset;

class IPCChainTester_create_account_presult {
 public:


  virtual ~IPCChainTester_create_account_presult() noexcept;
  std::string* success;

  _IPCChainTester_create_account_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _IPCChainTester_import_key_args__isset {
  _IPCChainTester_import_key_args__isset() : id(false), pub_key(false), priv_key(false) {}
  bool id :1;
  bool pub_key :1;
  bool priv_key :1;
} _IPCChainTester_import_key_args__isset;

class IPCChainTester_import_key_args {
 public:

  IPCChainTester_import_key_args(const IPCChainTester_import_key_args&);
  IPCChainTester_import_key_args& operator=(const IPCChainTester_import_key_args&);
  IPCChainTester_import_key_args() noexcept
                                 : id(0),
                                   pub_key(),
                                   priv_key() {
  }

  virtual ~IPCChainTester_import_key_args() noexcept;
  int32_t id;
  std::string pub_key;
  std::string priv_key;

  _IPCChainTester_import_key_args__isset __isset;

  void __set_id(const int32_t val);

  void __set_pub_key(const std::string& val);

  void __set_priv_key(const std::string& val);

  bool operator == (const IPCChainTester_import_key_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(pub_key == rhs.pub_key))
      return false;
    if (!(priv_key == rhs.priv_key))
      return false;
    return true;
  }
  bool operator != (const IPCChainTester_import_key_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_import_key_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class IPCChainTester_import_key_pargs {
 public:


  virtual ~IPCChainTester_import_key_pargs() noexcept;
  const int32_t* id;
  const std::string* pub_key;
  const std::string* priv_key;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _IPCChainTester_import_key_result__isset {
  _IPCChainTester_import_key_result__isset() : success(false) {}
  bool success :1;
} _IPCChainTester_import_key_result__isset;

class IPCChainTester_import_key_result {
 public:

  IPCChainTester_import_key_result(const IPCChainTester_import_key_result&) noexcept;
  IPCChainTester_import_key_result& operator=(const IPCChainTester_import_key_result&) noexcept;
  IPCChainTester_import_key_result() noexcept
                                   : success(0) {
  }

  virtual ~IPCChainTester_import_key_result() noexcept;
  bool success;

  _IPCChainTester_import_key_result__isset __isset;

  void __set_success(const bool val);

  bool operator == (const IPCChainTester_import_key_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const IPCChainTester_import_key_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_import_key_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _IPCChainTester_import_key_presult__isset {
  _IPCChainTester_import_key_presult__isset() : success(false) {}
  bool success :1;
} _IPCChainTester_import_key_presult__isset;

class IPCChainTester_import_key_presult {
 public:


  virtual ~IPCChainTester_import_key_presult() noexcept;
  bool* success;

  _IPCChainTester_import_key_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _IPCChainTester_get_required_keys_args__isset {
  _IPCChainTester_get_required_keys_args__isset() : id(false), transaction(false), available_keys(false) {}
  bool id :1;
  bool transaction :1;
  bool available_keys :1;
} _IPCChainTester_get_required_keys_args__isset;

class IPCChainTester_get_required_keys_args {
 public:

  IPCChainTester_get_required_keys_args(const IPCChainTester_get_required_keys_args&);
  IPCChainTester_get_required_keys_args& operator=(const IPCChainTester_get_required_keys_args&);
  IPCChainTester_get_required_keys_args() noexcept
                                        : id(0),
                                          transaction() {
  }

  virtual ~IPCChainTester_get_required_keys_args() noexcept;
  int32_t id;
  std::string transaction;
  std::vector<std::string>  available_keys;

  _IPCChainTester_get_required_keys_args__isset __isset;

  void __set_id(const int32_t val);

  void __set_transaction(const std::string& val);

  void __set_available_keys(const std::vector<std::string> & val);

  bool operator == (const IPCChainTester_get_required_keys_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(transaction == rhs.transaction))
      return false;
    if (!(available_keys == rhs.available_keys))
      return false;
    return true;
  }
  bool operator != (const IPCChainTester_get_required_keys_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_get_required_keys_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class IPCChainTester_get_required_keys_pargs {
 public:


  virtual ~IPCChainTester_get_required_keys_pargs() noexcept;
  const int32_t* id;
  const std::string* transaction;
  const std::vector<std::string> * available_keys;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _IPCChainTester_get_required_keys_result__isset {
  _IPCChainTester_get_required_keys_result__isset() : success(false) {}
  bool success :1;
} _IPCChainTester_get_required_keys_result__isset;

class IPCChainTester_get_required_keys_result {
 public:

  IPCChainTester_get_required_keys_result(const IPCChainTester_get_required_keys_result&);
  IPCChainTester_get_required_keys_result& operator=(const IPCChainTester_get_required_keys_result&);
  IPCChainTester_get_required_keys_result() noexcept
                                          : success() {
  }

  virtual ~IPCChainTester_get_required_keys_result() noexcept;
  std::string success;

  _IPCChainTester_get_required_keys_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const IPCChainTester_get_required_keys_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const IPCChainTester_get_required_keys_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_get_required_keys_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _IPCChainTester_get_required_keys_presult__isset {
  _IPCChainTester_get_required_keys_presult__isset() : success(false) {}
  bool success :1;
} _IPCChainTester_get_required_keys_presult__isset;

class IPCChainTester_get_required_keys_presult {
 public:


  virtual ~IPCChainTester_get_required_keys_presult() noexcept;
  std::string* success;

  _IPCChainTester_get_required_keys_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _IPCChainTester_produce_block_args__isset {
  _IPCChainTester_produce_block_args__isset() : id(false), next_block_skip_seconds(false) {}
  bool id :1;
  bool next_block_skip_seconds :1;
} _IPCChainTester_produce_block_args__isset;

class IPCChainTester_produce_block_args {
 public:

  IPCChainTester_produce_block_args(const IPCChainTester_produce_block_args&) noexcept;
  IPCChainTester_produce_block_args& operator=(const IPCChainTester_produce_block_args&) noexcept;
  IPCChainTester_produce_block_args() noexcept
                                    : id(0),
                                      next_block_skip_seconds(0) {
  }

  virtual ~IPCChainTester_produce_block_args() noexcept;
  int32_t id;
  int64_t next_block_skip_seconds;

  _IPCChainTester_produce_block_args__isset __isset;

  void __set_id(const int32_t val);

  void __set_next_block_skip_seconds(const int64_t val);

  bool operator == (const IPCChainTester_produce_block_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(next_block_skip_seconds == rhs.next_block_skip_seconds))
      return false;
    return true;
  }
  bool operator != (const IPCChainTester_produce_block_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_produce_block_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class IPCChainTester_produce_block_pargs {
 public:


  virtual ~IPCChainTester_produce_block_pargs() noexcept;
  const int32_t* id;
  const int64_t* next_block_skip_seconds;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class IPCChainTester_produce_block_result {
 public:

  IPCChainTester_produce_block_result(const IPCChainTester_produce_block_result&) noexcept;
  IPCChainTester_produce_block_result& operator=(const IPCChainTester_produce_block_result&) noexcept;
  IPCChainTester_produce_block_result() noexcept {
  }

  virtual ~IPCChainTester_produce_block_result() noexcept;

  bool operator == (const IPCChainTester_produce_block_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const IPCChainTester_produce_block_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_produce_block_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class IPCChainTester_produce_block_presult {
 public:


  virtual ~IPCChainTester_produce_block_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _IPCChainTester_push_action_args__isset {
  _IPCChainTester_push_action_args__isset() : id(false), account(false), action(false), arguments(false), permissions(false) {}
  bool id :1;
  bool account :1;
  bool action :1;
  bool arguments :1;
  bool permissions :1;
} _IPCChainTester_push_action_args__isset;

class IPCChainTester_push_action_args {
 public:

  IPCChainTester_push_action_args(const IPCChainTester_push_action_args&);
  IPCChainTester_push_action_args& operator=(const IPCChainTester_push_action_args&);
  IPCChainTester_push_action_args() noexcept
                                  : id(0),
                                    account(),
                                    action(),
                                    permissions() {
  }

  virtual ~IPCChainTester_push_action_args() noexcept;
  int32_t id;
  std::string account;
  std::string action;
  ActionArguments arguments;
  std::string permissions;

  _IPCChainTester_push_action_args__isset __isset;

  void __set_id(const int32_t val);

  void __set_account(const std::string& val);

  void __set_action(const std::string& val);

  void __set_arguments(const ActionArguments& val);

  void __set_permissions(const std::string& val);

  bool operator == (const IPCChainTester_push_action_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(account == rhs.account))
      return false;
    if (!(action == rhs.action))
      return false;
    if (!(arguments == rhs.arguments))
      return false;
    if (!(permissions == rhs.permissions))
      return false;
    return true;
  }
  bool operator != (const IPCChainTester_push_action_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_push_action_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class IPCChainTester_push_action_pargs {
 public:


  virtual ~IPCChainTester_push_action_pargs() noexcept;
  const int32_t* id;
  const std::string* account;
  const std::string* action;
  const ActionArguments* arguments;
  const std::string* permissions;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _IPCChainTester_push_action_result__isset {
  _IPCChainTester_push_action_result__isset() : success(false) {}
  bool success :1;
} _IPCChainTester_push_action_result__isset;

class IPCChainTester_push_action_result {
 public:

  IPCChainTester_push_action_result(const IPCChainTester_push_action_result&);
  IPCChainTester_push_action_result& operator=(const IPCChainTester_push_action_result&);
  IPCChainTester_push_action_result() noexcept
                                    : success() {
  }

  virtual ~IPCChainTester_push_action_result() noexcept;
  std::string success;

  _IPCChainTester_push_action_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const IPCChainTester_push_action_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const IPCChainTester_push_action_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_push_action_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _IPCChainTester_push_action_presult__isset {
  _IPCChainTester_push_action_presult__isset() : success(false) {}
  bool success :1;
} _IPCChainTester_push_action_presult__isset;

class IPCChainTester_push_action_presult {
 public:


  virtual ~IPCChainTester_push_action_presult() noexcept;
  std::string* success;

  _IPCChainTester_push_action_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _IPCChainTester_push_actions_args__isset {
  _IPCChainTester_push_actions_args__isset() : id(false), actions(false) {}
  bool id :1;
  bool actions :1;
} _IPCChainTester_push_actions_args__isset;

class IPCChainTester_push_actions_args {
 public:

  IPCChainTester_push_actions_args(const IPCChainTester_push_actions_args&);
  IPCChainTester_push_actions_args& operator=(const IPCChainTester_push_actions_args&);
  IPCChainTester_push_actions_args() noexcept
                                   : id(0) {
  }

  virtual ~IPCChainTester_push_actions_args() noexcept;
  int32_t id;
  std::vector<Action>  actions;

  _IPCChainTester_push_actions_args__isset __isset;

  void __set_id(const int32_t val);

  void __set_actions(const std::vector<Action> & val);

  bool operator == (const IPCChainTester_push_actions_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(actions == rhs.actions))
      return false;
    return true;
  }
  bool operator != (const IPCChainTester_push_actions_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_push_actions_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class IPCChainTester_push_actions_pargs {
 public:


  virtual ~IPCChainTester_push_actions_pargs() noexcept;
  const int32_t* id;
  const std::vector<Action> * actions;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _IPCChainTester_push_actions_result__isset {
  _IPCChainTester_push_actions_result__isset() : success(false) {}
  bool success :1;
} _IPCChainTester_push_actions_result__isset;

class IPCChainTester_push_actions_result {
 public:

  IPCChainTester_push_actions_result(const IPCChainTester_push_actions_result&);
  IPCChainTester_push_actions_result& operator=(const IPCChainTester_push_actions_result&);
  IPCChainTester_push_actions_result() noexcept
                                     : success() {
  }

  virtual ~IPCChainTester_push_actions_result() noexcept;
  std::string success;

  _IPCChainTester_push_actions_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const IPCChainTester_push_actions_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const IPCChainTester_push_actions_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_push_actions_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _IPCChainTester_push_actions_presult__isset {
  _IPCChainTester_push_actions_presult__isset() : success(false) {}
  bool success :1;
} _IPCChainTester_push_actions_presult__isset;

class IPCChainTester_push_actions_presult {
 public:


  virtual ~IPCChainTester_push_actions_presult() noexcept;
  std::string* success;

  _IPCChainTester_push_actions_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _IPCChainTester_deploy_contract_args__isset {
  _IPCChainTester_deploy_contract_args__isset() : id(false), account(false), wasm(false), abi(false) {}
  bool id :1;
  bool account :1;
  bool wasm :1;
  bool abi :1;
} _IPCChainTester_deploy_contract_args__isset;

class IPCChainTester_deploy_contract_args {
 public:

  IPCChainTester_deploy_contract_args(const IPCChainTester_deploy_contract_args&);
  IPCChainTester_deploy_contract_args& operator=(const IPCChainTester_deploy_contract_args&);
  IPCChainTester_deploy_contract_args() noexcept
                                      : id(0),
                                        account(),
                                        wasm(),
                                        abi() {
  }

  virtual ~IPCChainTester_deploy_contract_args() noexcept;
  int32_t id;
  std::string account;
  std::string wasm;
  std::string abi;

  _IPCChainTester_deploy_contract_args__isset __isset;

  void __set_id(const int32_t val);

  void __set_account(const std::string& val);

  void __set_wasm(const std::string& val);

  void __set_abi(const std::string& val);

  bool operator == (const IPCChainTester_deploy_contract_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(account == rhs.account))
      return false;
    if (!(wasm == rhs.wasm))
      return false;
    if (!(abi == rhs.abi))
      return false;
    return true;
  }
  bool operator != (const IPCChainTester_deploy_contract_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_deploy_contract_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class IPCChainTester_deploy_contract_pargs {
 public:


  virtual ~IPCChainTester_deploy_contract_pargs() noexcept;
  const int32_t* id;
  const std::string* account;
  const std::string* wasm;
  const std::string* abi;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _IPCChainTester_deploy_contract_result__isset {
  _IPCChainTester_deploy_contract_result__isset() : success(false) {}
  bool success :1;
} _IPCChainTester_deploy_contract_result__isset;

class IPCChainTester_deploy_contract_result {
 public:

  IPCChainTester_deploy_contract_result(const IPCChainTester_deploy_contract_result&);
  IPCChainTester_deploy_contract_result& operator=(const IPCChainTester_deploy_contract_result&);
  IPCChainTester_deploy_contract_result() noexcept
                                        : success() {
  }

  virtual ~IPCChainTester_deploy_contract_result() noexcept;
  std::string success;

  _IPCChainTester_deploy_contract_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const IPCChainTester_deploy_contract_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const IPCChainTester_deploy_contract_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_deploy_contract_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _IPCChainTester_deploy_contract_presult__isset {
  _IPCChainTester_deploy_contract_presult__isset() : success(false) {}
  bool success :1;
} _IPCChainTester_deploy_contract_presult__isset;

class IPCChainTester_deploy_contract_presult {
 public:


  virtual ~IPCChainTester_deploy_contract_presult() noexcept;
  std::string* success;

  _IPCChainTester_deploy_contract_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _IPCChainTester_get_table_rows_args__isset {
  _IPCChainTester_get_table_rows_args__isset() : id(false), json(false), code(false), scope(false), table(false), lower_bound(false), upper_bound(false), limit(false), key_type(false), index_position(false), reverse(false), show_payer(false) {}
  bool id :1;
  bool json :1;
  bool code :1;
  bool scope :1;
  bool table :1;
  bool lower_bound :1;
  bool upper_bound :1;
  bool limit :1;
  bool key_type :1;
  bool index_position :1;
  bool reverse :1;
  bool show_payer :1;
} _IPCChainTester_get_table_rows_args__isset;

class IPCChainTester_get_table_rows_args {
 public:

  IPCChainTester_get_table_rows_args(const IPCChainTester_get_table_rows_args&);
  IPCChainTester_get_table_rows_args& operator=(const IPCChainTester_get_table_rows_args&);
  IPCChainTester_get_table_rows_args() noexcept
                                     : id(0),
                                       json(0),
                                       code(),
                                       scope(),
                                       table(),
                                       lower_bound(),
                                       upper_bound(),
                                       limit(0),
                                       key_type(),
                                       index_position(),
                                       reverse(0),
                                       show_payer(0) {
  }

  virtual ~IPCChainTester_get_table_rows_args() noexcept;
  int32_t id;
  bool json;
  std::string code;
  std::string scope;
  std::string table;
  std::string lower_bound;
  std::string upper_bound;
  int64_t limit;
  std::string key_type;
  std::string index_position;
  bool reverse;
  bool show_payer;

  _IPCChainTester_get_table_rows_args__isset __isset;

  void __set_id(const int32_t val);

  void __set_json(const bool val);

  void __set_code(const std::string& val);

  void __set_scope(const std::string& val);

  void __set_table(const std::string& val);

  void __set_lower_bound(const std::string& val);

  void __set_upper_bound(const std::string& val);

  void __set_limit(const int64_t val);

  void __set_key_type(const std::string& val);

  void __set_index_position(const std::string& val);

  void __set_reverse(const bool val);

  void __set_show_payer(const bool val);

  bool operator == (const IPCChainTester_get_table_rows_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(json == rhs.json))
      return false;
    if (!(code == rhs.code))
      return false;
    if (!(scope == rhs.scope))
      return false;
    if (!(table == rhs.table))
      return false;
    if (!(lower_bound == rhs.lower_bound))
      return false;
    if (!(upper_bound == rhs.upper_bound))
      return false;
    if (!(limit == rhs.limit))
      return false;
    if (!(key_type == rhs.key_type))
      return false;
    if (!(index_position == rhs.index_position))
      return false;
    if (!(reverse == rhs.reverse))
      return false;
    if (!(show_payer == rhs.show_payer))
      return false;
    return true;
  }
  bool operator != (const IPCChainTester_get_table_rows_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_get_table_rows_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class IPCChainTester_get_table_rows_pargs {
 public:


  virtual ~IPCChainTester_get_table_rows_pargs() noexcept;
  const int32_t* id;
  const bool* json;
  const std::string* code;
  const std::string* scope;
  const std::string* table;
  const std::string* lower_bound;
  const std::string* upper_bound;
  const int64_t* limit;
  const std::string* key_type;
  const std::string* index_position;
  const bool* reverse;
  const bool* show_payer;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _IPCChainTester_get_table_rows_result__isset {
  _IPCChainTester_get_table_rows_result__isset() : success(false) {}
  bool success :1;
} _IPCChainTester_get_table_rows_result__isset;

class IPCChainTester_get_table_rows_result {
 public:

  IPCChainTester_get_table_rows_result(const IPCChainTester_get_table_rows_result&);
  IPCChainTester_get_table_rows_result& operator=(const IPCChainTester_get_table_rows_result&);
  IPCChainTester_get_table_rows_result() noexcept
                                       : success() {
  }

  virtual ~IPCChainTester_get_table_rows_result() noexcept;
  std::string success;

  _IPCChainTester_get_table_rows_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const IPCChainTester_get_table_rows_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const IPCChainTester_get_table_rows_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPCChainTester_get_table_rows_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _IPCChainTester_get_table_rows_presult__isset {
  _IPCChainTester_get_table_rows_presult__isset() : success(false) {}
  bool success :1;
} _IPCChainTester_get_table_rows_presult__isset;

class IPCChainTester_get_table_rows_presult {
 public:


  virtual ~IPCChainTester_get_table_rows_presult() noexcept;
  std::string* success;

  _IPCChainTester_get_table_rows_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class IPCChainTesterClient : virtual public IPCChainTesterIf {
 public:
  IPCChainTesterClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  IPCChainTesterClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void init_vm_api() override;
  void send_init_vm_api();
  void init_apply_request() override;
  void send_init_apply_request();
  bool set_native_contract(const std::string& contract, const std::string& dylib) override;
  void send_set_native_contract(const std::string& contract, const std::string& dylib);
  bool recv_set_native_contract();
  void enable_debug_contract(const int32_t id, const std::string& contract, const bool enable) override;
  void send_enable_debug_contract(const int32_t id, const std::string& contract, const bool enable);
  void recv_enable_debug_contract();
  bool is_debug_contract_enabled(const int32_t id, const std::string& contract) override;
  void send_is_debug_contract_enabled(const int32_t id, const std::string& contract);
  bool recv_is_debug_contract_enabled();
  void pack_abi(std::string& _return, const std::string& abi) override;
  void send_pack_abi(const std::string& abi);
  void recv_pack_abi(std::string& _return);
  void pack_action_args(std::string& _return, const int32_t id, const std::string& contract, const std::string& action, const std::string& action_args) override;
  void send_pack_action_args(const int32_t id, const std::string& contract, const std::string& action, const std::string& action_args);
  void recv_pack_action_args(std::string& _return);
  void unpack_action_args(std::string& _return, const int32_t id, const std::string& contract, const std::string& action, const std::string& raw_args) override;
  void send_unpack_action_args(const int32_t id, const std::string& contract, const std::string& action, const std::string& raw_args);
  void recv_unpack_action_args(std::string& _return);
  int32_t new_chain(const bool initialize) override;
  void send_new_chain(const bool initialize);
  int32_t recv_new_chain();
  int32_t free_chain(const int32_t id) override;
  void send_free_chain(const int32_t id);
  int32_t recv_free_chain();
  void get_info(std::string& _return, const int32_t id) override;
  void send_get_info(const int32_t id);
  void recv_get_info(std::string& _return);
  void create_key(std::string& _return, const std::string& key_type) override;
  void send_create_key(const std::string& key_type);
  void recv_create_key(std::string& _return);
  void get_account(std::string& _return, const int32_t id, const std::string& account) override;
  void send_get_account(const int32_t id, const std::string& account);
  void recv_get_account(std::string& _return);
  void create_account(std::string& _return, const int32_t id, const std::string& creator, const std::string& account, const std::string& owner_key, const std::string& active_key, const int64_t ram_bytes, const int64_t stake_net, const int64_t stake_cpu) override;
  void send_create_account(const int32_t id, const std::string& creator, const std::string& account, const std::string& owner_key, const std::string& active_key, const int64_t ram_bytes, const int64_t stake_net, const int64_t stake_cpu);
  void recv_create_account(std::string& _return);
  bool import_key(const int32_t id, const std::string& pub_key, const std::string& priv_key) override;
  void send_import_key(const int32_t id, const std::string& pub_key, const std::string& priv_key);
  bool recv_import_key();
  void get_required_keys(std::string& _return, const int32_t id, const std::string& transaction, const std::vector<std::string> & available_keys) override;
  void send_get_required_keys(const int32_t id, const std::string& transaction, const std::vector<std::string> & available_keys);
  void recv_get_required_keys(std::string& _return);
  void produce_block(const int32_t id, const int64_t next_block_skip_seconds) override;
  void send_produce_block(const int32_t id, const int64_t next_block_skip_seconds);
  void recv_produce_block();
  void push_action(std::string& _return, const int32_t id, const std::string& account, const std::string& action, const ActionArguments& arguments, const std::string& permissions) override;
  void send_push_action(const int32_t id, const std::string& account, const std::string& action, const ActionArguments& arguments, const std::string& permissions);
  void recv_push_action(std::string& _return);
  void push_actions(std::string& _return, const int32_t id, const std::vector<Action> & actions) override;
  void send_push_actions(const int32_t id, const std::vector<Action> & actions);
  void recv_push_actions(std::string& _return);
  void deploy_contract(std::string& _return, const int32_t id, const std::string& account, const std::string& wasm, const std::string& abi) override;
  void send_deploy_contract(const int32_t id, const std::string& account, const std::string& wasm, const std::string& abi);
  void recv_deploy_contract(std::string& _return);
  void get_table_rows(std::string& _return, const int32_t id, const bool json, const std::string& code, const std::string& scope, const std::string& table, const std::string& lower_bound, const std::string& upper_bound, const int64_t limit, const std::string& key_type, const std::string& index_position, const bool reverse, const bool show_payer) override;
  void send_get_table_rows(const int32_t id, const bool json, const std::string& code, const std::string& scope, const std::string& table, const std::string& lower_bound, const std::string& upper_bound, const int64_t limit, const std::string& key_type, const std::string& index_position, const bool reverse, const bool show_payer);
  void recv_get_table_rows(std::string& _return);
 protected:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class IPCChainTesterProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  ::std::shared_ptr<IPCChainTesterIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) override;
 private:
  typedef  void (IPCChainTesterProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_init_vm_api(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_init_apply_request(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_set_native_contract(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_enable_debug_contract(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_is_debug_contract_enabled(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_pack_abi(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_pack_action_args(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_unpack_action_args(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_new_chain(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_free_chain(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_info(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_create_key(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_account(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_create_account(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_import_key(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_required_keys(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_produce_block(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_push_action(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_push_actions(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_deploy_contract(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_table_rows(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  IPCChainTesterProcessor(::std::shared_ptr<IPCChainTesterIf> iface) :
    iface_(iface) {
    processMap_["init_vm_api"] = &IPCChainTesterProcessor::process_init_vm_api;
    processMap_["init_apply_request"] = &IPCChainTesterProcessor::process_init_apply_request;
    processMap_["set_native_contract"] = &IPCChainTesterProcessor::process_set_native_contract;
    processMap_["enable_debug_contract"] = &IPCChainTesterProcessor::process_enable_debug_contract;
    processMap_["is_debug_contract_enabled"] = &IPCChainTesterProcessor::process_is_debug_contract_enabled;
    processMap_["pack_abi"] = &IPCChainTesterProcessor::process_pack_abi;
    processMap_["pack_action_args"] = &IPCChainTesterProcessor::process_pack_action_args;
    processMap_["unpack_action_args"] = &IPCChainTesterProcessor::process_unpack_action_args;
    processMap_["new_chain"] = &IPCChainTesterProcessor::process_new_chain;
    processMap_["free_chain"] = &IPCChainTesterProcessor::process_free_chain;
    processMap_["get_info"] = &IPCChainTesterProcessor::process_get_info;
    processMap_["create_key"] = &IPCChainTesterProcessor::process_create_key;
    processMap_["get_account"] = &IPCChainTesterProcessor::process_get_account;
    processMap_["create_account"] = &IPCChainTesterProcessor::process_create_account;
    processMap_["import_key"] = &IPCChainTesterProcessor::process_import_key;
    processMap_["get_required_keys"] = &IPCChainTesterProcessor::process_get_required_keys;
    processMap_["produce_block"] = &IPCChainTesterProcessor::process_produce_block;
    processMap_["push_action"] = &IPCChainTesterProcessor::process_push_action;
    processMap_["push_actions"] = &IPCChainTesterProcessor::process_push_actions;
    processMap_["deploy_contract"] = &IPCChainTesterProcessor::process_deploy_contract;
    processMap_["get_table_rows"] = &IPCChainTesterProcessor::process_get_table_rows;
  }

  virtual ~IPCChainTesterProcessor() {}
};

class IPCChainTesterProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  IPCChainTesterProcessorFactory(const ::std::shared_ptr< IPCChainTesterIfFactory >& handlerFactory) noexcept :
      handlerFactory_(handlerFactory) {}

  ::std::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) override;

 protected:
  ::std::shared_ptr< IPCChainTesterIfFactory > handlerFactory_;
};

class IPCChainTesterMultiface : virtual public IPCChainTesterIf {
 public:
  IPCChainTesterMultiface(std::vector<std::shared_ptr<IPCChainTesterIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~IPCChainTesterMultiface() {}
 protected:
  std::vector<std::shared_ptr<IPCChainTesterIf> > ifaces_;
  IPCChainTesterMultiface() {}
  void add(::std::shared_ptr<IPCChainTesterIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void init_vm_api() override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->init_vm_api();
    }
    ifaces_[i]->init_vm_api();
  }

  void init_apply_request() override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->init_apply_request();
    }
    ifaces_[i]->init_apply_request();
  }

  bool set_native_contract(const std::string& contract, const std::string& dylib) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->set_native_contract(contract, dylib);
    }
    return ifaces_[i]->set_native_contract(contract, dylib);
  }

  void enable_debug_contract(const int32_t id, const std::string& contract, const bool enable) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->enable_debug_contract(id, contract, enable);
    }
    ifaces_[i]->enable_debug_contract(id, contract, enable);
  }

  bool is_debug_contract_enabled(const int32_t id, const std::string& contract) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->is_debug_contract_enabled(id, contract);
    }
    return ifaces_[i]->is_debug_contract_enabled(id, contract);
  }

  void pack_abi(std::string& _return, const std::string& abi) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->pack_abi(_return, abi);
    }
    ifaces_[i]->pack_abi(_return, abi);
    return;
  }

  void pack_action_args(std::string& _return, const int32_t id, const std::string& contract, const std::string& action, const std::string& action_args) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->pack_action_args(_return, id, contract, action, action_args);
    }
    ifaces_[i]->pack_action_args(_return, id, contract, action, action_args);
    return;
  }

  void unpack_action_args(std::string& _return, const int32_t id, const std::string& contract, const std::string& action, const std::string& raw_args) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->unpack_action_args(_return, id, contract, action, raw_args);
    }
    ifaces_[i]->unpack_action_args(_return, id, contract, action, raw_args);
    return;
  }

  int32_t new_chain(const bool initialize) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->new_chain(initialize);
    }
    return ifaces_[i]->new_chain(initialize);
  }

  int32_t free_chain(const int32_t id) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->free_chain(id);
    }
    return ifaces_[i]->free_chain(id);
  }

  void get_info(std::string& _return, const int32_t id) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_info(_return, id);
    }
    ifaces_[i]->get_info(_return, id);
    return;
  }

  void create_key(std::string& _return, const std::string& key_type) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->create_key(_return, key_type);
    }
    ifaces_[i]->create_key(_return, key_type);
    return;
  }

  void get_account(std::string& _return, const int32_t id, const std::string& account) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_account(_return, id, account);
    }
    ifaces_[i]->get_account(_return, id, account);
    return;
  }

  void create_account(std::string& _return, const int32_t id, const std::string& creator, const std::string& account, const std::string& owner_key, const std::string& active_key, const int64_t ram_bytes, const int64_t stake_net, const int64_t stake_cpu) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->create_account(_return, id, creator, account, owner_key, active_key, ram_bytes, stake_net, stake_cpu);
    }
    ifaces_[i]->create_account(_return, id, creator, account, owner_key, active_key, ram_bytes, stake_net, stake_cpu);
    return;
  }

  bool import_key(const int32_t id, const std::string& pub_key, const std::string& priv_key) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->import_key(id, pub_key, priv_key);
    }
    return ifaces_[i]->import_key(id, pub_key, priv_key);
  }

  void get_required_keys(std::string& _return, const int32_t id, const std::string& transaction, const std::vector<std::string> & available_keys) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_required_keys(_return, id, transaction, available_keys);
    }
    ifaces_[i]->get_required_keys(_return, id, transaction, available_keys);
    return;
  }

  void produce_block(const int32_t id, const int64_t next_block_skip_seconds) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->produce_block(id, next_block_skip_seconds);
    }
    ifaces_[i]->produce_block(id, next_block_skip_seconds);
  }

  void push_action(std::string& _return, const int32_t id, const std::string& account, const std::string& action, const ActionArguments& arguments, const std::string& permissions) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->push_action(_return, id, account, action, arguments, permissions);
    }
    ifaces_[i]->push_action(_return, id, account, action, arguments, permissions);
    return;
  }

  void push_actions(std::string& _return, const int32_t id, const std::vector<Action> & actions) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->push_actions(_return, id, actions);
    }
    ifaces_[i]->push_actions(_return, id, actions);
    return;
  }

  void deploy_contract(std::string& _return, const int32_t id, const std::string& account, const std::string& wasm, const std::string& abi) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->deploy_contract(_return, id, account, wasm, abi);
    }
    ifaces_[i]->deploy_contract(_return, id, account, wasm, abi);
    return;
  }

  void get_table_rows(std::string& _return, const int32_t id, const bool json, const std::string& code, const std::string& scope, const std::string& table, const std::string& lower_bound, const std::string& upper_bound, const int64_t limit, const std::string& key_type, const std::string& index_position, const bool reverse, const bool show_payer) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_table_rows(_return, id, json, code, scope, table, lower_bound, upper_bound, limit, key_type, index_position, reverse, show_payer);
    }
    ifaces_[i]->get_table_rows(_return, id, json, code, scope, table, lower_bound, upper_bound, limit, key_type, index_position, reverse, show_payer);
    return;
  }

};

// The 'concurrent' client is a thread safe client that correctly handles
// out of order responses.  It is slower than the regular client, so should
// only be used when you need to share a connection among multiple threads
class IPCChainTesterConcurrentClient : virtual public IPCChainTesterIf {
 public:
  IPCChainTesterConcurrentClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot, std::shared_ptr<::apache::thrift::async::TConcurrentClientSyncInfo> sync) : sync_(sync)
{
    setProtocol(prot);
  }
  IPCChainTesterConcurrentClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot, std::shared_ptr<::apache::thrift::async::TConcurrentClientSyncInfo> sync) : sync_(sync)
{
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void init_vm_api() override;
  void send_init_vm_api();
  void init_apply_request() override;
  void send_init_apply_request();
  bool set_native_contract(const std::string& contract, const std::string& dylib) override;
  int32_t send_set_native_contract(const std::string& contract, const std::string& dylib);
  bool recv_set_native_contract(const int32_t seqid);
  void enable_debug_contract(const int32_t id, const std::string& contract, const bool enable) override;
  int32_t send_enable_debug_contract(const int32_t id, const std::string& contract, const bool enable);
  void recv_enable_debug_contract(const int32_t seqid);
  bool is_debug_contract_enabled(const int32_t id, const std::string& contract) override;
  int32_t send_is_debug_contract_enabled(const int32_t id, const std::string& contract);
  bool recv_is_debug_contract_enabled(const int32_t seqid);
  void pack_abi(std::string& _return, const std::string& abi) override;
  int32_t send_pack_abi(const std::string& abi);
  void recv_pack_abi(std::string& _return, const int32_t seqid);
  void pack_action_args(std::string& _return, const int32_t id, const std::string& contract, const std::string& action, const std::string& action_args) override;
  int32_t send_pack_action_args(const int32_t id, const std::string& contract, const std::string& action, const std::string& action_args);
  void recv_pack_action_args(std::string& _return, const int32_t seqid);
  void unpack_action_args(std::string& _return, const int32_t id, const std::string& contract, const std::string& action, const std::string& raw_args) override;
  int32_t send_unpack_action_args(const int32_t id, const std::string& contract, const std::string& action, const std::string& raw_args);
  void recv_unpack_action_args(std::string& _return, const int32_t seqid);
  int32_t new_chain(const bool initialize) override;
  int32_t send_new_chain(const bool initialize);
  int32_t recv_new_chain(const int32_t seqid);
  int32_t free_chain(const int32_t id) override;
  int32_t send_free_chain(const int32_t id);
  int32_t recv_free_chain(const int32_t seqid);
  void get_info(std::string& _return, const int32_t id) override;
  int32_t send_get_info(const int32_t id);
  void recv_get_info(std::string& _return, const int32_t seqid);
  void create_key(std::string& _return, const std::string& key_type) override;
  int32_t send_create_key(const std::string& key_type);
  void recv_create_key(std::string& _return, const int32_t seqid);
  void get_account(std::string& _return, const int32_t id, const std::string& account) override;
  int32_t send_get_account(const int32_t id, const std::string& account);
  void recv_get_account(std::string& _return, const int32_t seqid);
  void create_account(std::string& _return, const int32_t id, const std::string& creator, const std::string& account, const std::string& owner_key, const std::string& active_key, const int64_t ram_bytes, const int64_t stake_net, const int64_t stake_cpu) override;
  int32_t send_create_account(const int32_t id, const std::string& creator, const std::string& account, const std::string& owner_key, const std::string& active_key, const int64_t ram_bytes, const int64_t stake_net, const int64_t stake_cpu);
  void recv_create_account(std::string& _return, const int32_t seqid);
  bool import_key(const int32_t id, const std::string& pub_key, const std::string& priv_key) override;
  int32_t send_import_key(const int32_t id, const std::string& pub_key, const std::string& priv_key);
  bool recv_import_key(const int32_t seqid);
  void get_required_keys(std::string& _return, const int32_t id, const std::string& transaction, const std::vector<std::string> & available_keys) override;
  int32_t send_get_required_keys(const int32_t id, const std::string& transaction, const std::vector<std::string> & available_keys);
  void recv_get_required_keys(std::string& _return, const int32_t seqid);
  void produce_block(const int32_t id, const int64_t next_block_skip_seconds) override;
  int32_t send_produce_block(const int32_t id, const int64_t next_block_skip_seconds);
  void recv_produce_block(const int32_t seqid);
  void push_action(std::string& _return, const int32_t id, const std::string& account, const std::string& action, const ActionArguments& arguments, const std::string& permissions) override;
  int32_t send_push_action(const int32_t id, const std::string& account, const std::string& action, const ActionArguments& arguments, const std::string& permissions);
  void recv_push_action(std::string& _return, const int32_t seqid);
  void push_actions(std::string& _return, const int32_t id, const std::vector<Action> & actions) override;
  int32_t send_push_actions(const int32_t id, const std::vector<Action> & actions);
  void recv_push_actions(std::string& _return, const int32_t seqid);
  void deploy_contract(std::string& _return, const int32_t id, const std::string& account, const std::string& wasm, const std::string& abi) override;
  int32_t send_deploy_contract(const int32_t id, const std::string& account, const std::string& wasm, const std::string& abi);
  void recv_deploy_contract(std::string& _return, const int32_t seqid);
  void get_table_rows(std::string& _return, const int32_t id, const bool json, const std::string& code, const std::string& scope, const std::string& table, const std::string& lower_bound, const std::string& upper_bound, const int64_t limit, const std::string& key_type, const std::string& index_position, const bool reverse, const bool show_payer) override;
  int32_t send_get_table_rows(const int32_t id, const bool json, const std::string& code, const std::string& scope, const std::string& table, const std::string& lower_bound, const std::string& upper_bound, const int64_t limit, const std::string& key_type, const std::string& index_position, const bool reverse, const bool show_payer);
  void recv_get_table_rows(std::string& _return, const int32_t seqid);
 protected:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
  std::shared_ptr<::apache::thrift::async::TConcurrentClientSyncInfo> sync_;
};

#ifdef _MSC_VER
  #pragma warning( pop )
#endif

} // namespace

#endif
